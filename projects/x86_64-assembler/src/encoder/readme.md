# InstructionEncoder 模块

## 模块职责

`InstructionEncoder` 负责将 `Instruction` 枚举转换为 x86/x86_64 机器码字节序列。核心逻辑在 `encode()` 方法中，通过模式匹配处理不同指令类型的编码细节。

## 关键数据结构

架构信息主要影响：
- 寄存器编号（x86 vs x86_64 的寄存器映射差异）
- REX 前缀生成逻辑（64 位操作需要 REX 前缀）
- 默认操作数大小（32 位 vs 64 位）

## 核心算法流程

### encode() 主流程
1. 模式匹配 `Instruction` 枚举
2. 根据操作数类型选择编码函数  
3. 处理寄存器/立即数/内存操作数的编码差异
4. 生成必要的指令前缀（REX、操作数大小等）
5. 组合操作码和操作数编码

例如：
```rust
use x86_64_assembler::encoder::InstructionEncoder;
use gaia_types::helpers::Architecture;

let encoder = InstructionEncoder::new(Architecture::X86_64);
// 编码逻辑在这里实现
```

### 寄存器编码逻辑
关键函数：`encode_register_operand()`
- 处理寄存器编号映射（`register_code()`）
- 处理 64 位寄存器的 REX 前缀需求
- 处理寄存器大小与操作码的匹配

### 内存操作数编码
关键函数：`encode_memory_operand()`
- SIB 字节生成逻辑（Scale-Index-Base）
- 位移（displacement）编码优化
- 特殊寻址模式处理（如 `[rip+disp32]`）

### 立即数编码
关键函数：`encode_immediate_operand()`
- 立即数大小与操作数大小的一致性检查
- 小立即数的特殊编码优化（如 `add eax, imm8`）

## 指令前缀生成

### REX 前缀
生成条件：
- 64 位操作（REX.W = 1）
- 访问扩展寄存器（REX.B/R/X 位）
- 64 位模式下默认操作数大小为 32 位，需要 REX 前缀来启用 64 位操作

### 操作数大小前缀（0x66）
生成条件：
- 16 位操作数在 32/64 位模式下
- 注意：64 位模式下 32 位操作是默认的，不需要前缀

## 架构差异处理

### x86 (32 位) vs x86_64 (64 位)
- 寄存器编号：x86_64 有扩展寄存器 R8-R15
- 寻址模式：x86_64 支持 RIP 相对寻址
- 默认操作数大小：x86 默认 32 位，x86_64 默认 32 位（需要 REX 前缀才能 64 位）

### 常见坑点
1. **REX 前缀遗漏**：64 位寄存器操作必须检查 REX 需求
2. **立即数大小混淆**：立即数大小必须与操作数大小匹配
3. **内存寻址模式**：某些组合在特定架构下无效
4. **操作码选择**：同一指令可能有多个操作码形式

## 性能考虑

### 编码优化
- 优先使用短操作码形式（如 `add eax, imm8` vs `add eax, imm32`）
- 内存操作数的 SIB 字节优化（避免不必要的 SIB）
- 立即数大小优化（能用 8 位就不用 32 位）

### 内存分配
当前实现每次编码都新建 `Vec<u8>`，对于批量编码场景可以考虑：
- 预分配缓冲区
- 重用编码器实例
- 提供编码到现有缓冲区的 API

## 错误处理策略

### 编码失败场景
- 操作数大小不匹配（如 `mov eax, imm64`）
- 不支持的寻址模式（如 `[rax+rbx*8+disp32]` 在 x86 下）
- 架构不支持的寄存器（如 R8 在 x86 下）

### 错误信息设计
错误类型应包含足够的上下文信息，方便定位问题：
- 涉及的具体指令类型
- 失败的操作数信息
- 期望 vs 实际的参数值

## 测试策略

### 单元测试重点
- 每种指令类型的基本编码
- 边界条件（最大/最小的立即数）
- 架构差异（同一指令在 x86 vs x86_64 的表现）
- 错误条件（无效操作数组合）

### 回归测试
- 已有指令的编码结果不应改变
- 新增指令不能破坏现有功能
- 性能基准测试（避免编码速度退化）

## 扩展指南

### 新增指令类型
1. 在 `Instruction` 枚举中添加新变体
2. 在 `encode()` 中添加对应的模式匹配分支
3. 实现具体的编码逻辑函数
4. 添加相应的测试用例

### 新增操作数类型
1. 在 `Operand` 枚举中添加新变体
2. 在 `encode_operand()` 中添加处理逻辑
3. 考虑对现有指令的影响（是否需要更新）

### 架构扩展
1. 在 `Architecture` 枚举中添加新架构
2. 更新寄存器编码映射
3. 调整前缀生成逻辑
4. 考虑向后兼容性

## 代码组织

### 文件结构
- `mod.rs`: 主模块，包含 `InstructionEncoder` 定义和核心编码逻辑
- 内部函数按操作数类型组织：`encode_register_operand()`、`encode_memory_operand()` 等

### 命名约定
- 编码函数：`encode_*_operand()`
- 辅助函数：`register_code()`、`needs_rex_prefix()` 等
- 常量：`REX_PREFIX`、`OPERAND_SIZE_PREFIX` 等

## 维护注意事项

1. **Intel vs AT&T 语法**：内部使用 Intel 语法（目标, 源）
2. **操作码参考**：主要参考 Intel 手册，注意不同版本间的差异
3. **字节序**：立即数和地址使用小端字节序
4. **对齐要求**：当前实现不考虑指令对齐优化