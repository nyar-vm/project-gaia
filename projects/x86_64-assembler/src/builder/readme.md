# ProgramBuilder 模块

## 设计定位

`ProgramBuilder` 是汇编器的高级 API 层，核心设计思路是：**提供类型安全的指令构建接口，隐藏底层指令创建的复杂性**。它不是简单的指令收集器，而是一个语义感知的程序构建协调器。

## 架构决策

### 1. 流式接口 vs 命令式接口
选择了方法链式调用（`builder.mov().push().call()`）而非分离的 `add_instruction()` 调用，原因：
- 更符合汇编代码的书写直觉
- 编译时就能发现大部分类型错误
- 减少用户侧的样板代码

### 2. 专用方法 vs 通用方法  
为常见指令模式提供专用方法（`mov_reg_imm()`）而非通用的 `add_instruction(Mov{...})`，原因：
- 强制参数类型检查，减少运行时错误
- 方法签名即文档，降低学习成本
- 未来可以在专用方法中加入优化逻辑

### 3. 立即处理 vs 延迟处理
当前采用立即验证策略（方法调用时检查），考虑未来支持延迟验证：
- 立即验证：错误早发现，调试简单
- 延迟验证：支持更复杂的跨指令优化
- 当前选择立即验证，后续可根据需求调整

## 核心数据结构

ProgramBuilder 是汇编器的高级 API 层，核心设计思路是：提供类型安全的指令构建接口，隐藏底层指令创建的复杂性。

**核心组件：**
- `architecture`: 架构约束源，贯穿整个构建过程
- `instructions`: 指令序列，保持插入顺序
- `data_sections`: 数据段管理，独立地址空间

**设计考量：**
- `Architecture` 作为不可变约束，贯穿整个构建过程
- `Vec<Instruction>` 保持插入顺序，支持标签前向引用
- `DataSection` 独立管理，避免指令和数据的耦合

## 方法分类策略

### 1. 寄存器操作指令
统一命名模式：`<op>_<dst-type>_<src-type>`
- `mov_reg_imm()` - 寄存器 ← 立即数
- `mov_reg_reg()` - 寄存器 ← 寄存器  
- `mov_reg_label()` - 寄存器 ← 标签地址

**一致性规则：**
- 目标总是第一个参数（符合 x86 操作数顺序）
- 立即数参数用基本类型（`i64`/`u64`）而非 `Operand`
- 寄存器参数直接用 `Register` 枚举

### 2. 栈操作指令
区分立即数和寄存器版本：
- `push_imm()` / `push_reg()` / `push_label()`
- `pop_reg()` （栈操作只有寄存器目标）

**架构感知：** 自动处理 x86 vs x86_64 的栈指针大小差异

### 3. 控制流指令  
简化调用接口：
- `call(target: &str)` - 直接调用，字符串标签
- `ret()` - 无参数返回
- 未来可扩展：`call_reg()` / `call_imm()`

## 错误处理策略

### 验证层级
1. **语法层**：参数类型和数量（编译时）
2. **语义层**：寄存器架构兼容性（运行时）  
3. **架构层**：指令在目标架构上的有效性（运行时）

### 错误类型设计

提供详细的错误信息，包含具体的上下文和调试信息。

**错误特征：**
- 包含具体的寄存器、架构信息
- 提供清晰的错误上下文描述
- 支持分层验证策略（语法、语义、架构层）
- 错误信息包含调试所需的全部信息

**分层验证策略：**
- **语法层**：立即数范围检查，寄存器存在性验证
- **语义层**：架构兼容性检查，操作数类型匹配
- **架构层**：指令集支持度，特权级别要求

## 数据段管理

### 设计哲学
数据段是**独立地址空间**，与指令流解耦：
- 支持多数据段，按名称区分
- 提供对齐选项，满足 SIMD/缓存需求  
- 不自动处理数据段引用，留给链接阶段

### 对齐策略
数据段对齐通过专门的 API 提供，支持 2 的幂次对齐要求。

**实现细节：**
- 对齐必须是 2 的幂次
- 记录对齐要求，实际地址在链接时确定
- 支持平台特定的最大对齐值查询

## 扩展设计

### 新增指令方法的路径
1. **分析使用频率**：常用指令才值得专用方法
2. **参数复杂度**：参数组合简单的优先
3. **架构通用性**：x86/x86_64 都支持的才添加

**反例：** 不添加 `mov_mem_reg()`，因为内存操作数构建复杂
**正例：** 添加 `mov_reg_imm()`，因为使用频繁且参数简单

## 性能考量

### 内存分配策略
- `instructions: Vec<Instruction>` 预分配容量（常见程序大小）
- `data_sections` 通常较少，不预优化
- 考虑提供 `with_capacity(instructions: usize)` 构造函数

### 构建时 vs 运行时权衡
当前设计偏向**构建时验证**，牺牲部分运行时性能换取：
- 更好的开发体验（早期错误发现）
- 更清晰的错误信息
- 更简单的实现（无需复杂优化pass）

## 与其他模块的交互

```text
用户代码 → ProgramBuilder → Vec<Instruction> → InstructionEncoder → Vec<u8>
                ↓
            Vec<DataSection> → 链接器 → 最终二进制
```

**职责边界：**
- **ProgramBuilder**：语义验证 + 指令收集
- **InstructionEncoder**：纯粹编码，不做验证  
- **链接器**（未来）：地址解析 + 重定位

## 常见陷阱

1. **架构假设**：方法内部不要硬编码架构特性（如寄存器编号）
2. **立即数范围**：`i64` 参数不意味着所有值都合法，需架构感知验证
3. **标签生命周期**：字符串标签在构建阶段不解析，避免过早验证
4. **方法顺序**：保持字母顺序，便于查找和维护
5. **错误信息**：包含具体参数值，方便用户调试