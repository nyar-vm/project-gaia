# x86_64-assembler 维护文档

## 项目概述

本项目是一个强类型的 x86/x86_64 汇编器实现，采用 Rust 语言开发。设计目标是提供可靠、高效且易于维护的汇编指令编码/解码功能。

## 架构设计

### 核心设计原则
- **强类型优先**: 利用 Rust 类型系统在编译期捕获错误
- **零依赖核心**: 核心库不依赖外部 crate，确保稳定性
- **模块化设计**: 清晰的模块边界，降低维护复杂度
- **性能导向**: 关键路径零分配，缓存友好设计

### 技术栈
- **语言**: Rust (Edition 2021)
- **构建工具**: Cargo
- **测试框架**: 内置测试 + 文档测试
- **CI/CD**: GitHub Actions (待配置)

## 模块架构

### 模块职责划分

#### 1. `assembler` 模块 - 主入口点
- **职责**: 提供统一的公共 API 接口
- **关键类型**: `X86_64Assembler` - 主汇编器结构体
- **设计考量**: 门面模式，隐藏内部复杂性，提供简洁接口

#### 2. `builder` 模块 - 高级 API 层  
- **职责**: 类型安全的指令构建接口
- **关键类型**: `ProgramBuilder` - 程序构建器
- **设计考量**: 流式接口设计，编译期类型检查，运行时验证

#### 3. `instruction` 模块 - 核心数据结构
- **职责**: 定义汇编语言的语义模型
- **关键类型**: `Instruction`, `Operand`, `Register` 枚举
- **设计考量**: 代数数据类型，精确表达 x86 语义，零成本抽象

#### 4. `encoder` 模块 - 编码引擎
- **职责**: 指令到字节码的转换
- **关键算法**: 两阶段编码 - 长度计算 + 实际编码
- **设计考量**: 零分配策略，缓存友好，分支预测优化

#### 5. `decoder` 模块 - 解码引擎
- **职责**: 字节码到指令的逆向解析
- **关键算法**: 三阶段解码 - 前缀解析 + 操作码识别 + 操作数解码
- **设计考量**: 查找表优化，状态机设计，错误恢复机制

## 模块详细文档

各模块包含详细的维护文档，涵盖：

- **设计决策**: 架构选择的权衡分析
- **算法说明**: 关键算法的实现细节
- **性能考量**: 优化策略和性能特征
- **扩展指南**: 如何添加新功能
- **测试策略**: 测试覆盖和维护要求

详见各模块的 `readme.md` 文件。

## 开发环境配置

### 必需工具
- Rust 1.70+ (建议使用 rustup 管理)
- Cargo (随 Rust 一起安装)
- Git (版本控制)

### 推荐开发工具
- rust-analyzer (IDE 支持)
- cargo-watch (自动重新构建)
- cargo-tree (依赖分析)

### 常用命令
```bash
# 构建项目
cargo build

# 运行测试
cargo test

# 运行文档测试
cargo test --doc

# 生成文档
cargo doc --open

# 基准测试
cargo bench

# 检查代码质量
cargo clippy
```

## 发布流程

### 版本管理
- 遵循语义化版本控制 (SemVer)
- 主版本号: 不兼容的 API 修改
- 次版本号: 向下兼容的功能性新增
- 修订号: 向下兼容的问题修正

### 发布前检查清单
- [ ] 所有测试通过 (`cargo test`)
- [ ] 文档测试通过 (`cargo test --doc`)
- [ ] 无警告 (`cargo build`)
- [ ] 文档完整 (`cargo doc`)
- [ ] 版本号更新 (`Cargo.toml`)
- [ ] CHANGELOG 更新

## 关键设计决策

### 架构抽象策略
- **统一接口**: 单一汇编器类型处理双架构，避免 API 分裂
- **运行时验证**: 架构检查在运行时进行，非编译期，提供灵活性
- **错误传播**: 使用 `Result<T, GaiaError>` 贯穿所有可能失败的 API

### 性能优化考量
- **零分配原则**: 核心路径避免堆分配，使用栈上数据结构
- **查找表优化**: 编码/解码大量使用预计算表，O(1) 复杂度
- **缓存友好**: 数据结构紧凑，提高 CPU 缓存命中率

### 可维护性设计
- **单一职责**: 每个模块专注特定功能，降低认知负担
- **显式错误**: 无 panic 路径，所有错误条件显式处理
- **文档驱动**: 公共 API 必须有文档，复杂算法有实现说明

## 维护指南

### 新增指令支持流程
1. **指令调研**: 查阅 Intel 手册，确认 opcode 和操作数格式
2. **类型定义**: 在 `instruction` 模块添加新的指令变体
3. **编码实现**: 在 `encoder` 模块添加编码逻辑
4. **解码实现**: 在 `decoder` 模块添加解码逻辑
5. **构建器集成**: 在 `builder` 模块添加便捷方法（如适用）
6. **测试覆盖**: 添加单元测试和集成测试，确保往返正确性

### 架构扩展考虑
- **新架构支持**: 需要修改 `Architecture` 枚举和所有架构相关匹配
- **寄存器扩展**: 影响 `Register` 枚举、编码表、解码逻辑
- **前缀处理**: 新增前缀需要修改 `PrefixState` 和相关解析逻辑

### 常见维护陷阱
1. **ModR/M 字节**: 256 种组合，每种情况都要测试
2. **REX 前缀**: x86_64 特有，容易遗漏边界情况
3. **位移符号扩展**: 8 位位移需要正确符号扩展到 32/64 位
4. **立即数字节序**: x86 小端序，多字节立即数注意顺序
5. **架构差异**: 同一指令在不同架构下可能行为不同

## 性能调优建议

### 基准测试
- 使用 `cargo bench` 进行性能基准测试
- 重点关注编码/解码吞吐量
- 监控内存分配情况（使用 `valgrind` 或类似工具）

### 优化方向
- **查找表大小**: 平衡内存使用和查找速度
- **分支预测**: 减少条件分支，提高预测准确率
- **内联策略**: 关键路径函数考虑 `#[inline]` 属性

## 错误处理策略

### 错误分类
- **输入错误**: 无效参数，不支持的架构等
- **编码错误**: 指令无法编码，操作数不匹配等
- **解码错误**: 无效字节序列，不支持的指令等
- **运行时错误**: 内存不足，内部状态不一致等

### 错误信息设计
- **具体性**: 包含具体的错误上下文和参数值
- **可操作性**: 提供明确的修复建议
- **一致性**: 错误格式统一，便于自动化处理